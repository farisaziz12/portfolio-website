---
/**
 * CountUp - Animated number counter
 * Inspired by ReactBits CountUp component
 * Supports decimal numbers
 */
interface Props {
  end: number;
  class?: string;
  duration?: number;
  delay?: number;
  suffix?: string;
  prefix?: string;
  decimals?: number;
}

const {
  end,
  class: className = '',
  duration = 2,
  delay = 0,
  suffix = '',
  prefix = '',
  decimals,
} = Astro.props;

// Auto-detect decimals if not specified
const decimalPlaces = decimals !== undefined ? decimals : (end % 1 !== 0 ? (end.toString().split('.')[1]?.length || 0) : 0);
---

<span
  class:list={['count-up', className]}
  data-count-up
  data-value={end}
  data-duration={duration}
  data-delay={delay}
  data-decimals={decimalPlaces}
>
  {prefix}<span class="count-up__number">0</span>{suffix}
</span>

<style>
  .count-up {
    display: inline-block;
    font-variant-numeric: tabular-nums;
  }

  .count-up__number {
    display: inline-block;
  }
</style>

<script>
  function easeOutExpo(t: number): number {
    return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
  }

  function animateCountUp(element: HTMLElement) {
    const numberEl = element.querySelector('.count-up__number');
    if (!numberEl) return;

    const targetValue = parseFloat(element.dataset.value || '0');
    const duration = parseFloat(element.dataset.duration || '2') * 1000;
    const delay = parseFloat(element.dataset.delay || '0') * 1000;
    const decimals = parseInt(element.dataset.decimals || '0', 10);

    let startTime: number | null = null;

    const formatNumber = (value: number): string => {
      if (decimals > 0) {
        return value.toFixed(decimals);
      }
      return Math.floor(value).toLocaleString();
    };

    const animate = (timestamp: number) => {
      if (!startTime) startTime = timestamp;
      const elapsed = timestamp - startTime;
      const progress = Math.min(elapsed / duration, 1);

      const currentValue = easeOutExpo(progress) * targetValue;
      numberEl.textContent = formatNumber(currentValue);

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        numberEl.textContent = formatNumber(targetValue);
      }
    };

    setTimeout(() => {
      requestAnimationFrame(animate);
    }, delay);
  }

  function initCountUp() {
    const elements = document.querySelectorAll('[data-count-up]');

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          animateCountUp(entry.target as HTMLElement);
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });

    elements.forEach(el => {
      // Reset number to 0 for page transitions
      const numberEl = el.querySelector('.count-up__number');
      if (numberEl) {
        numberEl.textContent = '0';
      }
      observer.observe(el);
    });
  }

  document.addEventListener('DOMContentLoaded', initCountUp);
  document.addEventListener('astro:after-swap', initCountUp);
</script>
